# Abstractions
Anywhere there is structure, there's usually patterns, even if we don't see them at first. Consider Newton's laws of motion; there's a handful of simple math equations that can be used to describe the motion of many objects in the scope of a high school physics class. Those equations are simply an abstraction: tools to organize and hide deeper and more complicated properties; that objects are made up of particles, and particles only interact with each other via a number of fundamental forces. The neat thing about abstractions is that they exist and can be useful, whether you know about them or not. When a computer Opens or Saves a file, there's a complicated dance that goes on inside the kernel on a PC to communicate with a storage device and issue commands, and then relay events and information back to the user mode application. The majority of people who use a computer are only aware of "reading" and "writing" to a file, not all the complicated implementation details that work behind the scenes.

Abstractions are very powerful, but they can also be very difficult to learn and understand. It took humans multiple centuries to move from discovering classical mechanics to quantum mechanics. Similarly, trying to learn about operating systems and study kernel design by inspecting raw machine code would be close to impossible. Having C language source code helps, but kernels often contain a lot of hand written assembly language, with the documentation written with the target audience of other kernel developers, which isn't a bad thing, but makes writing "modern" kernels a very difficult process to dive into. This is mainly because the C language and assembly language are among the first programming languages ever designed. Today, most programmers start off in Java or Python, and only dive into C or assembly out of necessity, and the learning curve is steep. I think the Rust language is a good stepping stone from Python or Java (automatic-memory-management) into manual-memory-management like C or assembly. And there are some projects out there to write a kernel in Rust. But even still, those projects still sometimes have components or documentation that was written for the target audience of other kernel developers/hackers, and can be difficult to grasp.

The "problem" (maybe trade-off is a better term) with Rust, is that the language only attempts to support abstractions that can be nearly zero-cost at runtime; and the language is designed for "production" or "enterprise" use. Again, these aren't bad traits to have, but they prevent the language from adding features which might make it easier to use or learn (like Python), in an attempt to keep the language "bare metal". I want to create a language that is easy to learn and write like python, but allows a path into enabling and including abstractions like those in Rust, OCaml, or Haskell, and that might aid in writing a (toy or research) kernel, with the trade-off of slower speed or lower efficiency.
